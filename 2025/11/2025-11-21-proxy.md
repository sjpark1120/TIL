# TIL: Proxy + Reflect 정리

## 1. Proxy란?

특정 객체를 감싸서 객체에 가해지는 **접근/변경을 가로채서 커스텀 동작**을 넣을 수 있는 기능.

- 객체의 get/set, delete, has 같은 작업을 직접 제어 가능.
- Vue3, Immer 등 반응성/불변성 라이브러리 내부에서 활용됨.
- 특수 객체(exotic object)

### 기본 예시

```js
let proxy = new Proxy(target, handler);
```

- target – 감싸게 될 객체로, 함수를 포함한 모든 객체가 가능하다.
- handler – 동작을 가로채는 메서드인 '트랩(trap)'이 담긴 객체로, 여기서 Proxy를 설정한다.

```js
const original = { a: 1 };

const proxy = new Proxy(original, {
  get(target, prop, receiver) {
    console.log("get:", prop);
    return Reflect.get(target, prop, receiver);
  },
  set(target, prop, value, receiver) {
    console.log("set:", prop, value);
    return Reflect.set(target, prop, value, receiver);
  },
});

proxy.a; // get 트리거
proxy.a = 10; // set 트리거
```

---

## 2. Reflect란?

Proxy 핸들러에서 **target에 실제 연산을 실행하는 표준 API**.

- 기존 연산자/내장 메서드의 함수 버전이라고 보면 됨.
- 실패 시 throw 대신 true/false 반환 등 일관된 규칙 제공.

즉, Reflect 객체는 Proxy와 같이 명령을 가로챌 수 있는 메서드를 제공하는 내장 객체로서 좀더 심플화한 객체라고 보면 된다.

### Reflect 메서드

- `Reflect.get(obj, prop)`
- `Reflect.set(obj, prop, value)`
- `Reflect.has(obj, prop)` → `'prop' in obj`
- `Reflect.deleteProperty(obj, prop)` → `delete obj[prop]`
- `Reflect.apply(fn, thisArg, args)`
- `Reflect.defineProperty(obj, prop, descriptor)`

---

## 3. Proxy와 Reflect의 관계

Proxy는 작업을 **가로채는 역할**,
Reflect는 그 작업을 **표준 방식으로 수행하는 역할**.

Reflect는 Proxy에서 트랩할 수 있는 모든 내부 메서드와 동일한 내장 메서드를 가지고 있다.
따라서 Reflect를 사용하면 원래 객체에 그대로 작업을 전달할 때 별도의 사이드 이펙트 없이 전달 가능하다

예시 흐름:

1. proxy에서 set 호출됨
2. set 트랩 실행 → 변경 로깅 등 원하는 동작 수행
3. 마지막에 `Reflect.set()`으로 실제 값 반영

---

## 4. Proxy + Reflect 사용하는 경우

### ✔ 객체 조작 과정을 정교하게 통제하고 싶을 때

- 로깅
- 권한 체크
- 유효성 검사

### ✔ 반응성(Reactivity) 구현

- Vue3의 reactive 시스템이 Proxy 기반
- get/set 가로채서 의존성 추적

### ✔ 불변성 관리

- Immer는 draft 객체를 Proxy로 감싼 뒤
  set/get을 감지하고 Reflect로 실제 변경 수행
